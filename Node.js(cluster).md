# Node.js - cluster

- Node.js의 인스턴스는 하나의 스레드에서 작동한다.

- 따라서 멀티 코어 시스템의 이점을 얻고 load를 처리하기 위해서 Node.js 프로세스의 cluster을 시작하기 원할 것이다.

- 클러스터 모듈은 서버 포트를 공유하는 자식 프로세스들을 쉽게  생성한다.

- Node.js 실행하면 worker들 간 포트 번호를 공유된다.

- 윈도우즈에서는 아직 worker의 named pipes server을 설정할 수 없다.

  - 파이프 : 프로세스 통신에 사용하는 공유 메모리의 단면도임

    - 파이프 종류

      - anonymous pipes

        > 일반적으로 부모 프로세스와 자식 프로세스 사이에서 데이터를 전송하는 익명의 단방향 파이프. 항상 로컬임(네트워크를 통한 통신에 사용 불가)

      - named pipes

        > 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 단방향 또는 양방향 파이프이다. 모든 인스턴스는 동일한 파이프 이름을 공유하지만 각 인스턴스에는 자체 버퍼와 핸들이 있으며 클라이언트/서버 통신을 위한 별도의 파이프를 제공한다. 인스턴스를 사용하면 여러 파이프 클라이언트가 동일한 named pipes를 동시에 사용할 수 있다.

  - 파이프 서버 : 파이프를 만드는 프로세스

  - 파이프 클라이언트 : 파이프에 연결하는 프로세스

- 작동 원리

- worker 프로세스는 child_process.fork() 메소드를 사용하여 생성되므로 IPC를 통해 부모와 통신할 수 있고 server handles를 앞 뒤로 전달할 수 있다.

- 클러스터 모듈은 수신 연결을 배포하는 2가지 방법이 있다.

- 첫번째(윈도우즈를 제외한 모든 플랫폼의 기본)는 기본 프로세스가 포트에서 수신 대기하고, 새로운 연결을 수락하고, 라운드 로빈 방식으로 작업자 전체에 배포하는 오버로딩을 피하는 똑똑한 worker 프로세스가 내장된 라운드 로빈 방식이다.

- 두번째 방법은 기본 프로세스가 청취 소켓을 생성하고 관련있는 workers들로 보내는 방법이다. 그 worker들은 들어오는 연결을 직접 수락한다.

- 두번째 방법은 이론상 최고의 성능을 제공해야 한다. 하지만 실제로는 운영체제 스케줄러의 변덕 때문에 매우 불균형한 배포를 하는 경향이 있다. 총 8개 중 2개의 프로세스 만이 모든 연결의 70%를 넘긴 Load들로 관측되었다.

- server.listen()은 대부분의 작업을 기본 프로세스로 넘기기 때문에, 일반 Node.js  프로세스와 cluster worker 사이에 다음 3가지 경우의 차이가 있다.

- 1. server.listen({fd:7}) 메시지가 기본적으로 전달되기 때문에, 7번 file descriptor을 참조하는 것에 대한 worker의 생각을 듣기보다는 부모에 있는 file descriptor 7을 듣고 worker로 핸들이 전달된다.

- 2. server.listen(handle) 핸들을 명시적으로 수신하면 worker가 일반 프로세스와 통신통신하기 보다 제공된 핸들을 사용하게 된다.

- 3. server.listen(0) 일반적으로 서버가 임의의 포트에서 수신 대기한다. 하지만 클러스터에서 각 worker들은 동일한 임의의 포트를 listen(0)할 때 받는다. 본질적으로 포트는 처음에는 랜덤하지만 이후에는 예측가능해진다. 고유 포트를 수신하기 위해서는 cluster worker ID를 기반으로 포트번호를 생성해라. 

- Node.js은 routing 로직을 제공하지 않는다. 그러므로 세션과 로그인 같은 것들에 대해 메모리 내 데이터 개체에 지나치게 의존하지 않게 응용프로그램을 설계하는 것이 중요하다.

- worker들은 모두 개별적인 프로세스이기 때문에 다른 worker들에 영향없이 프로그램의 필요에 따라 종료되거나 재생성될 수 있다. 일부 worker들이 남아있는 한, 서버는 연결을 수락한다. 만약 남아있는 worker들이 없다면, 기존 연결은 종료되고 새로운 연결은 거부될 것이다. Node.js는 worker들의 수를 자동적으로 관리하지 않는다. 자신의 필요에 따라 worker pool을 관리하는 것은 응용프로그램의 책임이다.

- cluster 모듈의 주요 사용 사례는 네트워킹이지만 작업자 프로세스가 필요한 다른 사용 사례에도 사용할 수 있다.

### Class: Worker

- Worker 객체는 worker 관련된 모든 공개 정보와 메소드를 포함한다. 일반적으로 cluster.workers를 사용하여 얻을 수 있다. worker 내에서는 cluster.worker을 사용하여 얻을 수 있다.

### Event:'disconnect'

- cluster.on('disconnect') 이벤트와 비슷하지만 worker에만 해당된다.

### Event:'error'

- 이 이벤트는 child_process.fork() 에서 제공되는 것과 동일하다.
- worker 안에서 process.on('error') 를 사용할 수 있다.

### Event: 'exit'

- code <number> 정상적으로 종료됐을 때 종료 코드다.
- signal <string> 프로세스를 종료시킨 신호의 이름이다.
- cluster.on('exit')와 비슷한 이벤트지만 worker에만 쓸 수 있다.

### Event: 'listening'

- cluster.on('listening') 이벤트와 비슷하지만 worker에만 사용할 수 있다.
- worker에 emit되지 않는다.

### Event: 'message'

- cluster의  message 이벤트와 비슷하지만 worker에만 사용할 수 있다.
- worker 안에서, process.on('message')를 사용할 수 있다.
- message 시스템을 사용하는 예제가 여기 있습니다. 그것은 worker가 수신한 HTTP 요청들의 수를 일반 프로세스에서 센다.

### Event: 'online'

- cluster.on('online') 이벤트와 비슷하지만 worker에만 사용할 수 있다.
- 이것은 worker에서 방출되지 않는다.

### worker.disconnect()

- worker에서, 이 기능은 서버를 닫고, 서버의 'close' 이벤트를 기다리고, IPC 채널의 연결을 끊는다.
- 일반적으로, 내부의 메시지는 worker에 전송되어 스스로 .disconnect()를 호출하도록 한다.
- .exitedAfterDisconnect를 설정하는 원인이다.
- 서버가 종료된 후에, 더 이상 새로운 연결을 수락하지 않지만, 다른 수신 worker들은 수락할 수도 있다. 기존 연결들을 평소와 같이 닫을 수 있다. 더 이상 연결이 존재하지 않을 때, server.close()를 참조해라. worker에 대한 IPC 채널이 닫히면서 정상적으로 종료된다.
- 위의 내용은 서버 연결에만 적용되고 클라이언트 연결에는 worker에 의해 자동적으로 닫히지 않고, 연결 해제는 종료하기 전에 닫힐 때 까지 기다리지 않는다.
- worker에, process.disconnect가 존재하지만 이 기능이 아니다. 이 기능은 disconnect() 이다.
- 오래 지속되는 서버 연결은 작업자의 연결이 끊어지는 것을 차단할 수 있기 때문에, 메시지를 보내는 것이 유용할 수 있으므로 응용 프로그램 특정 작업을 수행하여 작업자를 닫을 수 있다. 또한 시간 초과를 구현하여 일정 시간 후에도 'disconnect' 이벤트가 발생하지 않으면 작업자를 종료하는 것이 유용할 수 있다.